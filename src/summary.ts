import type { BatchResult, BatchTriageEntry, DuplicateCluster } from "./types.js";

const GITHUB_BODY_LIMIT = 65536;
const SECTION_ROW_LIMIT = 50;

export function buildSummaryIssue(result: BatchResult): { title: string; body: string } {
  const title = `ClawTriage Batch Report — ${result.repo} — ${result.timestamp.split("T")[0]}`;
  const { stats, clusters, entries } = result;
  const lines: string[] = [];

  lines.push(`## ClawTriage Batch Triage Report\n`);
  lines.push(`**Repository:** ${result.repo}`);
  lines.push(`**PRs analyzed:** ${result.totalPRs}`);
  lines.push(`**Run date:** ${result.timestamp}\n`);

  // Summary table
  lines.push(`### Summary\n`);
  lines.push(`| Metric | Count |`);
  lines.push(`|---|---|`);
  lines.push(`| Total PRs | ${stats.totalPRs} |`);
  lines.push(`| Duplicate clusters | ${stats.duplicateClusters} (${stats.duplicatePRs} PRs) |`);
  lines.push(`| Avg quality score | ${stats.avgQuality}/10 |`);
  lines.push(`| Vision: fits | ${stats.visionFits} |`);
  lines.push(`| Vision: strays | ${stats.visionStrays} |`);
  lines.push(`| Vision: rejects | ${stats.visionRejects} |`);
  lines.push(``);

  // Duplicate clusters
  if (clusters.length > 0) {
    lines.push(`### Duplicate Clusters\n`);
    const entryMap = new Map<number, BatchTriageEntry>();
    for (const e of entries) entryMap.set(e.prNumber, e);

    clusters.forEach((cluster: DuplicateCluster, i: number) => {
      lines.push(
        `**Cluster ${i + 1}** (avg similarity: ${Math.round(cluster.avgSimilarity * 100)}%) — Canonical: #${cluster.canonical}`,
      );
      for (const member of cluster.members) {
        const entry = entryMap.get(member);
        const memberTitle = entry ? entry.title : `PR #${member}`;
        lines.push(`- #${member}: ${memberTitle}`);
      }
      lines.push(``);
    });
  }

  // Top merge candidates (capped)
  const visionWasRun = entries.some((e) => e.visionAlignment !== "pending");
  const mergeCandidates = visionWasRun
    ? entries.filter((e) => e.qualityScore >= 8 && e.visionAlignment === "fits")
    : entries.filter((e) => e.qualityScore >= 8);
  mergeCandidates.sort((a, b) => b.qualityScore - a.qualityScore);
  if (mergeCandidates.length > 0) {
    const shown = mergeCandidates.slice(0, SECTION_ROW_LIMIT);
    const suffix = mergeCandidates.length > SECTION_ROW_LIMIT
      ? ` (top ${SECTION_ROW_LIMIT} of ${mergeCandidates.length})`
      : ``;
    const criteria = visionWasRun
      ? `quality >= 8, vision fits`
      : `quality >= 8, vision not run`;
    lines.push(`### Top Merge Candidates (${criteria})${suffix}\n`);
    lines.push(`| PR | Quality | Title |`);
    lines.push(`|---|---|---|`);
    for (const e of shown) {
      lines.push(`| #${e.prNumber} | ${e.qualityScore}/10 | ${e.title} |`);
    }
    lines.push(``);
  }

  // Needs revision (capped)
  const needsRevision = entries
    .filter((e) => e.qualityScore < 4)
    .sort((a, b) => a.qualityScore - b.qualityScore);
  if (needsRevision.length > 0) {
    const shown = needsRevision.slice(0, SECTION_ROW_LIMIT);
    const suffix = needsRevision.length > SECTION_ROW_LIMIT
      ? ` (worst ${SECTION_ROW_LIMIT} of ${needsRevision.length})`
      : ``;
    lines.push(`### Needs Revision (quality < 4)${suffix}\n`);
    lines.push(`| PR | Quality | Title |`);
    lines.push(`|---|---|---|`);
    for (const e of shown) {
      lines.push(`| #${e.prNumber} | ${e.qualityScore}/10 | ${e.title} |`);
    }
    lines.push(``);
  }

  // Vision rejects (capped)
  const visionRejects = entries.filter((e) => e.visionAlignment === "rejects");
  if (visionRejects.length > 0) {
    const shown = visionRejects.slice(0, SECTION_ROW_LIMIT);
    const suffix = visionRejects.length > SECTION_ROW_LIMIT
      ? ` (first ${SECTION_ROW_LIMIT} of ${visionRejects.length})`
      : ``;
    lines.push(`### Vision Rejects${suffix}\n`);
    lines.push(`| PR | Reason | Title |`);
    lines.push(`|---|---|---|`);
    for (const e of shown) {
      lines.push(`| #${e.prNumber} | ${e.visionReason} | ${e.title} |`);
    }
    lines.push(``);
  }

  // Full triage table — truncated to stay within GitHub body limit
  const FOOTER = `---\n*Generated by [ClawTriage](https://github.com/GriffinAtlas/clawtriage) — batch mode*`;

  const tableHeader = [
    `### Full Triage Table\n`,
    `<details>`,
    `<summary>All ${entries.length} PRs</summary>\n`,
    `| PR | Quality | Vision | Dupes | Action | Title |`,
    `|---|---|---|---|---|---|`,
  ];
  const tableRows: string[] = [];
  for (const e of entries) {
    const dupeLabel = e.duplicateCluster !== null ? `Cluster ${e.duplicateCluster + 1}` : "-";
    tableRows.push(
      `| #${e.prNumber} | ${e.qualityScore} | ${e.visionAlignment} | ${dupeLabel} | ${e.recommendedAction} | ${e.title} |`,
    );
  }
  const tableFooter = [`\n</details>\n`];

  const preambleLength = lines.join("\n").length;
  const footerLength = FOOTER.length;
  const headerLength = tableHeader.join("\n").length + tableFooter.join("\n").length;
  const budgetForRows = GITHUB_BODY_LIMIT - preambleLength - footerLength - headerLength - 500;

  lines.push(...tableHeader);

  if (budgetForRows > 0 && tableRows.join("\n").length <= budgetForRows) {
    lines.push(...tableRows);
  } else if (budgetForRows > 0) {
    let usedChars = 0;
    let includedCount = 0;
    for (const row of tableRows) {
      if (usedChars + row.length + 1 > budgetForRows) break;
      lines.push(row);
      usedChars += row.length + 1;
      includedCount++;
    }
    lines.push(``);
    lines.push(`*... truncated (${includedCount}/${entries.length} PRs shown). Full data available in batch JSON output.*`);
  } else {
    lines.push(`*Table omitted — summary sections exceeded size limit. Full data available in batch JSON output.*`);
  }

  lines.push(...tableFooter);
  lines.push(FOOTER);

  return { title, body: lines.join("\n") };
}
